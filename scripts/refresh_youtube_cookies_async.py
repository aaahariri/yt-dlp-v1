#!/usr/bin/env python3
"""
YouTube Cookie Refresh Script using Playwright (Async Version)

Async version of refresh_youtube_cookies.py for use in asyncio contexts
(FastAPI, RunPod workers, etc.)

Features:
- Auto-detects login success (no manual intervention needed)
- Supports push notification 2FA (user approves on phone)
- Uses saved browser state when available
- Configurable timeouts and retry logic
- Safe to call from asyncio event loops

Usage:
    from scripts.refresh_youtube_cookies_async import refresh_cookies_async

    # In async context
    success = await refresh_cookies_async(
        email="...",
        password="...",
        output_path="./cookies.txt"
    )
"""

import os
import sys
import asyncio
import logging
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple

# Load .env file if it exists
try:
    from dotenv import load_dotenv
    script_dir = Path(__file__).parent
    for env_path in [
        script_dir.parent / '.env',
        script_dir / '.env',
        Path.cwd() / '.env',
    ]:
        if env_path.exists():
            load_dotenv(env_path)
            break
except ImportError:
    pass

try:
    from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeout
except ImportError:
    print("Error: Playwright not installed.")
    print("Install with: pip install playwright && playwright install chromium")
    sys.exit(1)

logger = logging.getLogger(__name__)

# Configuration
LOGIN_CHECK_INTERVAL = 5  # seconds between login status checks
LOGIN_TIMEOUT_SECONDS = 300  # 5 minutes max wait for login


def convert_to_netscape_format(cookies: list, domain: str = ".youtube.com") -> str:
    """Convert Playwright cookies to Netscape cookie format for yt-dlp."""
    lines = ["# Netscape HTTP Cookie File", "# Generated by refresh_youtube_cookies_async.py", ""]

    for cookie in cookies:
        cookie_domain = cookie.get('domain', '')
        if not any(d in cookie_domain for d in ['youtube.com', 'google.com', 'googleapis.com']):
            continue

        domain_str = cookie_domain
        include_subdomains = "TRUE" if domain_str.startswith('.') else "FALSE"
        path = cookie.get('path', '/')
        secure = "TRUE" if cookie.get('secure', False) else "FALSE"
        expiry = str(int(cookie.get('expires', 0)))
        name = cookie.get('name', '')
        value = cookie.get('value', '')

        line = f"{domain_str}\t{include_subdomains}\t{path}\t{secure}\t{expiry}\t{name}\t{value}"
        lines.append(line)

    return '\n'.join(lines)


async def check_login_status(page) -> Tuple[bool, str]:
    """
    Check if user is logged into YouTube.

    Returns:
        (is_logged_in: bool, reason: str)
    """
    try:
        current_url = page.url

        # If still on Google login pages, not logged in yet
        if 'accounts.google.com' in current_url:
            if 'challenge' in current_url or 'signin/v2/challenge' in current_url:
                return False, "2fa_challenge"
            elif 'signin' in current_url:
                return False, "login_page"
            else:
                return False, "google_auth"

        # If on YouTube, check for logged-in indicators
        if 'youtube.com' in current_url:
            # Check for avatar button (strongest indicator of logged in)
            avatar_selectors = [
                'button#avatar-btn',
                'ytd-topbar-menu-button-renderer #avatar-btn',
                'img.yt-spec-avatar-shape__avatar',
                '#avatar-btn img',
            ]

            for selector in avatar_selectors:
                try:
                    if await page.locator(selector).count() > 0:
                        return True, "avatar_found"
                except Exception:
                    pass

            # Check for absence of sign-in button
            try:
                sign_in_buttons = await page.locator('a[href*="accounts.google.com/ServiceLogin"]').count()
                sign_in_text = await page.locator('ytd-button-renderer:has-text("Sign in")').count()

                if sign_in_buttons == 0 and sign_in_text == 0:
                    if await page.locator('ytd-topbar-menu-button-renderer').count() > 0:
                        return True, "no_signin_button"
            except Exception:
                pass

            return False, "youtube_not_logged_in"

        return False, f"unknown_page:{current_url[:50]}"

    except Exception as e:
        return False, f"check_error:{str(e)[:50]}"


async def wait_for_login_success(page, timeout_seconds: int = 300, check_interval: int = 5) -> Tuple[bool, str]:
    """
    Poll for successful login with configurable timeout.

    Returns:
        (success: bool, final_reason: str)
    """
    max_attempts = timeout_seconds // check_interval
    attempt = 0
    last_reason = "unknown"
    challenge_announced = False

    logger.info(f"Waiting for login (max {timeout_seconds}s, checking every {check_interval}s)...")

    while attempt < max_attempts:
        is_logged_in, reason = await check_login_status(page)
        last_reason = reason

        if is_logged_in:
            logger.info(f"Login detected: {reason}")
            return True, reason

        # Log progress every 30 seconds
        if attempt > 0 and attempt % 6 == 0:
            elapsed = attempt * check_interval
            logger.info(f"Still waiting for login... ({elapsed}s elapsed, status: {reason})")

        # Announce 2FA challenge once
        if reason == "2fa_challenge" and not challenge_announced:
            logger.warning("2FA challenge detected - waiting for user to approve on phone/device")
            challenge_announced = True

        await asyncio.sleep(check_interval)
        attempt += 1

    return False, f"timeout:{last_reason}"


async def check_already_logged_in(page) -> bool:
    """Check if already logged in via saved state."""
    try:
        logger.info("Checking if already logged in via saved state...")
        await page.goto('https://www.youtube.com', timeout=30000)
        await asyncio.sleep(3)

        is_logged_in, reason = await check_login_status(page)

        if is_logged_in:
            logger.info(f"Already logged in via saved state ({reason})")
            return True
        else:
            logger.info(f"Not logged in yet ({reason})")
            return False

    except Exception as e:
        logger.warning(f"Error checking login status: {e}")
        return False


async def perform_login(page, email: str, password: str) -> bool:
    """Enter email and password on Google login page."""
    logger.info("Performing login...")

    try:
        await page.goto('https://accounts.google.com/ServiceLogin?service=youtube')
        await asyncio.sleep(2)

        # Enter email
        logger.info("Entering email...")
        try:
            email_input = page.locator('input[type="email"]')
            await email_input.wait_for(state='visible', timeout=10000)
            await email_input.fill(email)

            next_button = page.locator('#identifierNext button, [data-idom-class*="nCP5yc"]').first
            await next_button.click()
            await asyncio.sleep(3)
        except Exception as e:
            logger.error(f"Error entering email: {e}")
            return False

        # Enter password
        logger.info("Entering password...")
        try:
            password_input = page.locator('input[type="password"]')
            await password_input.wait_for(state='visible', timeout=10000)
            await password_input.fill(password)

            next_button = page.locator('#passwordNext button, [data-idom-class*="nCP5yc"]').first
            await next_button.click()
            await asyncio.sleep(3)
        except Exception as e:
            logger.error(f"Error entering password: {e}")
            return False

        logger.info("Credentials entered, waiting for authentication...")
        return True

    except Exception as e:
        logger.error(f"Login error: {e}")
        return False


async def extract_and_save_cookies(context, page, output_path: str) -> bool:
    """Extract cookies and save to file."""
    try:
        logger.info("Stabilizing cookies...")
        await page.goto('https://www.youtube.com/robots.txt')
        await asyncio.sleep(2)

        logger.info("Extracting cookies...")
        cookies = await context.cookies()

        if not cookies:
            logger.error("No cookies found")
            return False

        netscape_cookies = convert_to_netscape_format(cookies)

        yt_cookies = [c for c in cookies if 'youtube' in c.get('domain', '') or 'google' in c.get('domain', '')]
        logger.info(f"Found {len(yt_cookies)} YouTube/Google cookies")

        # Check for essential cookies
        essential_cookies = ['SID', 'SSID', 'HSID', 'LOGIN_INFO']
        cookie_names = [c.get('name', '') for c in cookies]
        found_essential = [c for c in essential_cookies if c in cookie_names]

        if len(found_essential) < 2:
            logger.warning(f"Missing essential cookies. Found: {found_essential}")
        else:
            logger.info(f"Essential cookies present: {found_essential}")

        # Save to file
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        output_file.write_text(netscape_cookies)
        os.chmod(output_path, 0o600)

        logger.info(f"Cookies saved to: {output_path}")

        # Save browser state
        state_path = output_path.replace('.txt', '_state.json')
        await context.storage_state(path=state_path)
        os.chmod(state_path, 0o600)
        logger.info(f"Browser state saved to: {state_path}")

        return True

    except Exception as e:
        logger.error(f"Error extracting cookies: {e}")
        return False


async def refresh_cookies_async(
    email: str = None,
    password: str = None,
    output_path: str = None,
    timeout: int = 300
) -> bool:
    """
    Async function to refresh YouTube cookies.
    Safe to call from asyncio contexts (FastAPI, RunPod workers, etc.)

    Args:
        email: YouTube/Google email (or from YOUTUBE_EMAIL env)
        password: YouTube/Google password (or from YOUTUBE_PASSWORD env)
        output_path: Path to save cookies.txt (or from YTDLP_COOKIES_FILE env)
        timeout: Max seconds to wait for login

    Returns:
        True if cookies were successfully exported
    """
    email = email or os.getenv('YOUTUBE_EMAIL')
    password = password or os.getenv('YOUTUBE_PASSWORD')
    output_path = output_path or os.getenv('YTDLP_COOKIES_FILE', './cookies.txt')

    if not email or not password:
        logger.error("YouTube credentials not provided")
        return False

    logger.info(f"Starting YouTube cookie refresh (async)...")
    logger.info(f"Email: {email}")
    logger.info(f"Output: {output_path}")

    async with async_playwright() as p:
        browser = await p.chromium.launch(
            headless=True,
            args=[
                '--disable-blink-features=AutomationControlled',
                '--no-sandbox',
            ]
        )

        state_path = output_path.replace('.txt', '_state.json')
        has_saved_state = os.path.exists(state_path)

        if has_saved_state:
            logger.info(f"Found saved browser state: {state_path}")

        context = await browser.new_context(
            viewport={'width': 1280, 'height': 720},
            user_agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            locale='en-US',
            storage_state=state_path if has_saved_state else None,
        )

        page = await context.new_page()

        try:
            # Step 1: Check if already logged in via saved state
            if has_saved_state:
                if await check_already_logged_in(page):
                    if await extract_and_save_cookies(context, page, output_path):
                        logger.info("SUCCESS: Cookies refreshed using saved state")
                        await browser.close()
                        return True

            # Step 2: Perform login
            if not await perform_login(page, email, password):
                logger.error("Failed to enter credentials")
                await browser.close()
                return False

            # Step 3: Wait for login to complete (auto-detect)
            success, reason = await wait_for_login_success(page, timeout_seconds=timeout)

            if not success:
                logger.error(f"Login failed: {reason}")
                await browser.close()
                return False

            # Step 4: Extract and save cookies
            if not await extract_and_save_cookies(context, page, output_path):
                await browser.close()
                return False

            logger.info("SUCCESS: YouTube cookies refreshed")
            await browser.close()
            return True

        except Exception as e:
            logger.error(f"Error during async cookie refresh: {e}")
            await browser.close()
            return False


def is_running_in_async_context() -> bool:
    """Check if we're currently running inside an asyncio event loop."""
    try:
        asyncio.get_running_loop()
        return True
    except RuntimeError:
        return False


async def main_async():
    """Async main for testing."""
    logging.basicConfig(level=logging.INFO)
    success = await refresh_cookies_async()
    return success


if __name__ == '__main__':
    success = asyncio.run(main_async())
    sys.exit(0 if success else 1)
