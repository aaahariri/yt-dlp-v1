#!/usr/bin/env python3
"""
YouTube Cookie Refresh Script using Playwright

Automates YouTube login and exports cookies in Netscape format for yt-dlp.
Can run headless (automated) or headed (for 2FA/debugging).

Usage:
    # First time setup (installs browser)
    playwright install chromium

    # Interactive mode (shows browser, handles 2FA)
    python scripts/refresh_youtube_cookies.py --interactive

    # Headless mode (for cron jobs, requires no 2FA on account)
    python scripts/refresh_youtube_cookies.py

    # Custom output path
    python scripts/refresh_youtube_cookies.py --output /path/to/cookies.txt

Environment Variables:
    YOUTUBE_EMAIL    - YouTube/Google account email
    YOUTUBE_PASSWORD - YouTube/Google account password
    YTDLP_COOKIES_FILE - Default output path for cookies (optional)

Security Notes:
    - Use a throwaway account (ban risk)
    - Disable 2FA for automated mode, or use interactive mode
    - Never commit credentials or cookies to git
"""

import os
import sys
import json
import time
import argparse
from datetime import datetime
from pathlib import Path

try:
    from playwright.sync_api import sync_playwright, TimeoutError as PlaywrightTimeout
except ImportError:
    print("Error: Playwright not installed.")
    print("Install with: pip install playwright && playwright install chromium")
    sys.exit(1)


def convert_to_netscape_format(cookies: list, domain: str = ".youtube.com") -> str:
    """
    Convert Playwright cookies to Netscape cookie format for yt-dlp.

    Netscape format:
    # Netscape HTTP Cookie File
    domain\tinclude_subdomains\tpath\tsecure\texpiry\tname\tvalue
    """
    lines = ["# Netscape HTTP Cookie File", "# Generated by refresh_youtube_cookies.py", ""]

    for cookie in cookies:
        # Filter to YouTube/Google domains
        cookie_domain = cookie.get('domain', '')
        if not any(d in cookie_domain for d in ['youtube.com', 'google.com', 'googleapis.com']):
            continue

        domain_str = cookie_domain
        include_subdomains = "TRUE" if domain_str.startswith('.') else "FALSE"
        path = cookie.get('path', '/')
        secure = "TRUE" if cookie.get('secure', False) else "FALSE"
        expiry = str(int(cookie.get('expires', 0)))
        name = cookie.get('name', '')
        value = cookie.get('value', '')

        line = f"{domain_str}\t{include_subdomains}\t{path}\t{secure}\t{expiry}\t{name}\t{value}"
        lines.append(line)

    return '\n'.join(lines)


def wait_for_login_complete(page, timeout: int = 300):
    """Wait for YouTube login to complete by checking for logged-in indicators."""
    print("Waiting for login to complete...")

    start_time = time.time()
    while time.time() - start_time < timeout:
        # Check if we're on YouTube and logged in
        try:
            # Look for avatar button (indicates logged in)
            if page.locator('button#avatar-btn').count() > 0:
                print("Login detected (avatar button found)")
                return True

            # Alternative: check for "Sign in" button absence on youtube.com
            if 'youtube.com' in page.url:
                sign_in_buttons = page.locator('a[href*="accounts.google.com/ServiceLogin"]').count()
                if sign_in_buttons == 0 and page.locator('ytd-masthead').count() > 0:
                    # On YouTube with masthead but no sign-in link
                    time.sleep(2)  # Extra wait for cookies to settle
                    return True
        except Exception:
            pass

        time.sleep(1)

    return False


def login_to_youtube(page, email: str, password: str, interactive: bool = False):
    """
    Perform YouTube/Google login.

    For accounts with 2FA:
    - Use interactive mode (--interactive flag)
    - Or disable 2FA on the throwaway account
    """
    print(f"Navigating to YouTube login...")

    # Go to YouTube and click sign in
    page.goto('https://www.youtube.com')
    time.sleep(2)

    # Click sign in button
    try:
        sign_in_btn = page.locator('a[href*="accounts.google.com/ServiceLogin"]').first
        sign_in_btn.click(timeout=10000)
    except Exception:
        # Try alternative sign in button
        page.goto('https://accounts.google.com/ServiceLogin?service=youtube')

    time.sleep(2)

    # Enter email
    print("Entering email...")
    try:
        email_input = page.locator('input[type="email"]')
        email_input.fill(email)
        page.locator('#identifierNext button, [data-idom-class*="nCP5yc"]').first.click()
        time.sleep(3)
    except Exception as e:
        print(f"Error entering email: {e}")
        if interactive:
            print("Please enter email manually in the browser...")
            input("Press Enter when ready to continue...")

    # Enter password
    print("Entering password...")
    try:
        password_input = page.locator('input[type="password"]')
        password_input.wait_for(state='visible', timeout=10000)
        password_input.fill(password)
        page.locator('#passwordNext button, [data-idom-class*="nCP5yc"]').first.click()
        time.sleep(3)
    except Exception as e:
        print(f"Error entering password: {e}")
        if interactive:
            print("Please enter password manually in the browser...")
            input("Press Enter when ready to continue...")

    # Handle potential 2FA or security prompts
    if interactive:
        print("\n" + "="*50)
        print("INTERACTIVE MODE")
        print("="*50)
        print("If you see 2FA or security prompts, complete them in the browser.")
        print("Once you're logged into YouTube, press Enter to continue.")
        input("\nPress Enter when logged in...")
    else:
        # Check for 2FA prompt
        time.sleep(3)
        if 'challenge' in page.url or 'signin/v2' in page.url:
            print("\nWarning: 2FA or security challenge detected!")
            print("Options:")
            print("  1. Run with --interactive flag to handle manually")
            print("  2. Disable 2FA on the throwaway account")
            print("  3. Use an App Password if available")
            return False

    return True


def refresh_cookies(
    email: str = None,
    password: str = None,
    output_path: str = None,
    interactive: bool = False,
    timeout: int = 300
) -> bool:
    """
    Main function to refresh YouTube cookies.

    Args:
        email: YouTube/Google email (or from YOUTUBE_EMAIL env)
        password: YouTube/Google password (or from YOUTUBE_PASSWORD env)
        output_path: Path to save cookies.txt (or from YTDLP_COOKIES_FILE env)
        interactive: Show browser window for manual intervention
        timeout: Max seconds to wait for login

    Returns:
        True if cookies were successfully exported
    """
    # Get credentials from env if not provided
    email = email or os.getenv('YOUTUBE_EMAIL')
    password = password or os.getenv('YOUTUBE_PASSWORD')
    output_path = output_path or os.getenv('YTDLP_COOKIES_FILE', './cookies.txt')

    if not email or not password:
        print("Error: YouTube credentials not provided.")
        print("Set YOUTUBE_EMAIL and YOUTUBE_PASSWORD environment variables,")
        print("or pass --email and --password arguments.")
        return False

    print(f"Starting YouTube cookie refresh...")
    print(f"Output: {output_path}")
    print(f"Mode: {'Interactive' if interactive else 'Headless'}")
    print()

    with sync_playwright() as p:
        # Launch browser
        browser = p.chromium.launch(
            headless=not interactive,
            args=[
                '--disable-blink-features=AutomationControlled',
                '--no-sandbox',
            ]
        )

        # Check for saved browser state
        state_path = output_path.replace('.txt', '_state.json')
        has_saved_state = os.path.exists(state_path)

        if has_saved_state:
            print(f"Loading saved browser state from: {state_path}")

        # Create context with realistic settings (and saved state if available)
        context = browser.new_context(
            viewport={'width': 1280, 'height': 720},
            user_agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            locale='en-US',
            storage_state=state_path if has_saved_state else None,
        )

        page = context.new_page()

        try:
            # Perform login
            login_success = login_to_youtube(page, email, password, interactive)

            if not login_success and not interactive:
                print("Login failed. Try running with --interactive flag.")
                browser.close()
                return False

            # Wait for login to complete
            if not wait_for_login_complete(page, timeout):
                print("Timeout waiting for login. Try running with --interactive flag.")
                browser.close()
                return False

            # Navigate to robots.txt to stabilize cookies (prevents rotation)
            print("Navigating to robots.txt to stabilize cookies...")
            page.goto('https://www.youtube.com/robots.txt')
            time.sleep(2)

            # Get all cookies
            print("Extracting cookies...")
            cookies = context.cookies()

            if not cookies:
                print("Error: No cookies found after login.")
                browser.close()
                return False

            # Convert to Netscape format
            netscape_cookies = convert_to_netscape_format(cookies)

            # Count YouTube-specific cookies
            yt_cookies = [c for c in cookies if 'youtube' in c.get('domain', '') or 'google' in c.get('domain', '')]
            print(f"Found {len(yt_cookies)} YouTube/Google cookies")

            # Save to file
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
            output_file.write_text(netscape_cookies)

            # Set restrictive permissions
            os.chmod(output_path, 0o600)

            print(f"\nCookies saved to: {output_path}")
            print(f"Timestamp: {datetime.now().isoformat()}")

            # Also save Playwright state for future use (updates existing if present)
            context.storage_state(path=state_path)
            os.chmod(state_path, 0o600)
            print(f"Browser state saved to: {state_path}")

            browser.close()
            return True

        except Exception as e:
            print(f"Error during cookie refresh: {e}")
            browser.close()
            return False


def main():
    parser = argparse.ArgumentParser(
        description='Refresh YouTube cookies for yt-dlp',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Interactive mode (shows browser for 2FA)
    python refresh_youtube_cookies.py --interactive

    # Headless mode with env vars
    YOUTUBE_EMAIL=email@gmail.com YOUTUBE_PASSWORD=pass python refresh_youtube_cookies.py

    # Custom output
    python refresh_youtube_cookies.py --output ./cookies.txt --interactive

Environment Variables:
    YOUTUBE_EMAIL      - Google account email
    YOUTUBE_PASSWORD   - Google account password
    YTDLP_COOKIES_FILE - Default output path
        """
    )

    parser.add_argument(
        '--email', '-e',
        help='YouTube/Google email (or set YOUTUBE_EMAIL env var)'
    )
    parser.add_argument(
        '--password', '-p',
        help='YouTube/Google password (or set YOUTUBE_PASSWORD env var)'
    )
    parser.add_argument(
        '--output', '-o',
        default=os.getenv('YTDLP_COOKIES_FILE', './cookies.txt'),
        help='Output path for cookies.txt (default: ./cookies.txt)'
    )
    parser.add_argument(
        '--interactive', '-i',
        action='store_true',
        help='Show browser window (required for 2FA accounts)'
    )
    parser.add_argument(
        '--timeout', '-t',
        type=int,
        default=300,
        help='Timeout in seconds for login (default: 300)'
    )

    args = parser.parse_args()

    success = refresh_cookies(
        email=args.email,
        password=args.password,
        output_path=args.output,
        interactive=args.interactive,
        timeout=args.timeout
    )

    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
