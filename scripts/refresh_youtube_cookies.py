#!/usr/bin/env python3
"""
YouTube Cookie Refresh Script using Playwright

Automates YouTube login and exports cookies in Netscape format for yt-dlp.
Can run headless (automated) or headed (for 2FA/debugging).

Features:
- Auto-detects login success (no manual Enter press needed)
- Supports push notification 2FA (user approves on phone)
- Uses saved browser state when available
- Configurable timeouts and retry logic

Usage:
    # First time setup (installs browser)
    playwright install chromium

    # Interactive mode (shows browser, handles 2FA)
    python scripts/refresh_youtube_cookies.py --interactive

    # Headless mode (for automation, requires push-based 2FA or no 2FA)
    python scripts/refresh_youtube_cookies.py

    # Custom output path
    python scripts/refresh_youtube_cookies.py --output /path/to/cookies.txt

Environment Variables:
    YOUTUBE_EMAIL    - YouTube/Google account email
    YOUTUBE_PASSWORD - YouTube/Google account password
    YTDLP_COOKIES_FILE - Default output path for cookies (optional)

Security Notes:
    - Use a throwaway account (ban risk)
    - Disable 2FA for automated mode, or use push-based 2FA
    - Never commit credentials or cookies to git
"""

import os
import sys
import json
import time
import argparse
from datetime import datetime
from pathlib import Path

# Load .env file if it exists (look in script dir, parent dir, or cwd)
try:
    from dotenv import load_dotenv
    # Try multiple locations for .env
    script_dir = Path(__file__).parent
    for env_path in [
        script_dir.parent / '.env',  # Project root (most common)
        script_dir / '.env',          # Scripts dir
        Path.cwd() / '.env',          # Current working directory
    ]:
        if env_path.exists():
            load_dotenv(env_path)
            print(f"Loaded environment from: {env_path}")
            break
except ImportError:
    pass  # dotenv not installed, rely on shell environment

try:
    from playwright.sync_api import sync_playwright, TimeoutError as PlaywrightTimeout
except ImportError:
    print("Error: Playwright not installed.")
    print("Install with: pip install playwright && playwright install chromium")
    sys.exit(1)


# Configuration
LOGIN_CHECK_INTERVAL = 5  # seconds between login status checks
LOGIN_CHECK_RETRIES = 60  # max retries (60 * 5s = 5 minutes max wait)
CHALLENGE_WAIT_TIME = 300  # 5 minutes to complete 2FA challenge


def convert_to_netscape_format(cookies: list, domain: str = ".youtube.com") -> str:
    """
    Convert Playwright cookies to Netscape cookie format for yt-dlp.

    Netscape format:
    # Netscape HTTP Cookie File
    domain\tinclude_subdomains\tpath\tsecure\texpiry\tname\tvalue
    """
    lines = ["# Netscape HTTP Cookie File", "# Generated by refresh_youtube_cookies.py", ""]

    for cookie in cookies:
        # Filter to YouTube/Google domains
        cookie_domain = cookie.get('domain', '')
        if not any(d in cookie_domain for d in ['youtube.com', 'google.com', 'googleapis.com']):
            continue

        domain_str = cookie_domain
        include_subdomains = "TRUE" if domain_str.startswith('.') else "FALSE"
        path = cookie.get('path', '/')
        secure = "TRUE" if cookie.get('secure', False) else "FALSE"
        expiry = str(int(cookie.get('expires', 0)))
        name = cookie.get('name', '')
        value = cookie.get('value', '')

        line = f"{domain_str}\t{include_subdomains}\t{path}\t{secure}\t{expiry}\t{name}\t{value}"
        lines.append(line)

    return '\n'.join(lines)


def check_login_status(page) -> tuple:
    """
    Check if user is logged into YouTube.

    Returns:
        (is_logged_in: bool, reason: str)
    """
    try:
        current_url = page.url

        # If still on Google login pages, not logged in yet
        if 'accounts.google.com' in current_url:
            if 'challenge' in current_url or 'signin/v2/challenge' in current_url:
                return False, "2fa_challenge"
            elif 'signin' in current_url:
                return False, "login_page"
            else:
                return False, "google_auth"

        # If on YouTube, check for logged-in indicators
        if 'youtube.com' in current_url:
            # Check for avatar button (strongest indicator of logged in)
            avatar_selectors = [
                'button#avatar-btn',
                'ytd-topbar-menu-button-renderer #avatar-btn',
                'img.yt-spec-avatar-shape__avatar',
                '#avatar-btn img',
            ]

            for selector in avatar_selectors:
                try:
                    if page.locator(selector).count() > 0:
                        return True, "avatar_found"
                except Exception:
                    pass

            # Check for absence of sign-in button (secondary indicator)
            try:
                sign_in_buttons = page.locator('a[href*="accounts.google.com/ServiceLogin"]').count()
                # Also check for the "Sign in" text button
                sign_in_text = page.locator('ytd-button-renderer:has-text("Sign in")').count()

                if sign_in_buttons == 0 and sign_in_text == 0:
                    # No sign-in buttons and we're on YouTube - likely logged in
                    # Double-check by looking for user menu
                    if page.locator('ytd-topbar-menu-button-renderer').count() > 0:
                        return True, "no_signin_button"
            except Exception:
                pass

            return False, "youtube_not_logged_in"

        return False, f"unknown_page:{current_url[:50]}"

    except Exception as e:
        return False, f"check_error:{str(e)[:50]}"


def wait_for_login_success(page, timeout_seconds: int = 300, check_interval: int = 5) -> tuple:
    """
    Poll for successful login with configurable timeout.

    Args:
        page: Playwright page object
        timeout_seconds: Max time to wait for login
        check_interval: Seconds between status checks

    Returns:
        (success: bool, final_reason: str)
    """
    max_attempts = timeout_seconds // check_interval
    attempt = 0
    last_reason = "unknown"

    print(f"Waiting for login (max {timeout_seconds}s, checking every {check_interval}s)...")

    while attempt < max_attempts:
        is_logged_in, reason = check_login_status(page)
        last_reason = reason

        if is_logged_in:
            print(f"✓ Login detected: {reason}")
            return True, reason

        # Show progress every 30 seconds
        if attempt > 0 and attempt % 6 == 0:
            elapsed = attempt * check_interval
            print(f"  Still waiting... ({elapsed}s elapsed, status: {reason})")

        # If on 2FA challenge, inform user
        if reason == "2fa_challenge" and attempt == 0:
            print("")
            print("=" * 60)
            print("2FA CHALLENGE DETECTED")
            print("=" * 60)
            print("Please complete the verification on your phone or device.")
            print("The script will automatically continue once approved.")
            print(f"Waiting up to {timeout_seconds} seconds...")
            print("=" * 60)
            print("")

        time.sleep(check_interval)
        attempt += 1

    return False, f"timeout:{last_reason}"


def check_already_logged_in(page) -> bool:
    """
    Navigate to YouTube and check if already logged in via saved state.

    Returns True if already logged in, False otherwise.
    """
    try:
        print("Checking if already logged in via saved state...")
        page.goto('https://www.youtube.com', timeout=30000)
        time.sleep(3)  # Let page fully load

        is_logged_in, reason = check_login_status(page)

        if is_logged_in:
            print(f"✓ Already logged in via saved state ({reason})")
            return True
        else:
            print(f"Not logged in yet ({reason})")
            return False

    except Exception as e:
        print(f"Error checking login status: {e}")
        return False


def perform_login(page, email: str, password: str) -> bool:
    """
    Enter email and password on Google login page.

    Returns True if credentials were entered successfully, False otherwise.
    """
    print("Performing login...")

    try:
        # Go to YouTube sign-in
        page.goto('https://accounts.google.com/ServiceLogin?service=youtube')
        time.sleep(2)

        # Enter email
        print("  Entering email...")
        try:
            email_input = page.locator('input[type="email"]')
            email_input.wait_for(state='visible', timeout=10000)
            email_input.fill(email)

            # Click Next
            next_button = page.locator('#identifierNext button, [data-idom-class*="nCP5yc"]').first
            next_button.click()
            time.sleep(3)
        except Exception as e:
            print(f"  Error entering email: {e}")
            return False

        # Enter password
        print("  Entering password...")
        try:
            password_input = page.locator('input[type="password"]')
            password_input.wait_for(state='visible', timeout=10000)
            password_input.fill(password)

            # Click Next
            next_button = page.locator('#passwordNext button, [data-idom-class*="nCP5yc"]').first
            next_button.click()
            time.sleep(3)
        except Exception as e:
            print(f"  Error entering password: {e}")
            return False

        print("  Credentials entered, waiting for authentication...")
        return True

    except Exception as e:
        print(f"Login error: {e}")
        return False


def extract_and_save_cookies(context, page, output_path: str) -> bool:
    """
    Extract cookies and save to file.

    Returns True if successful, False otherwise.
    """
    try:
        # Navigate to robots.txt to stabilize cookies (prevents rotation)
        print("Stabilizing cookies...")
        page.goto('https://www.youtube.com/robots.txt')
        time.sleep(2)

        # Get all cookies
        print("Extracting cookies...")
        cookies = context.cookies()

        if not cookies:
            print("Error: No cookies found")
            return False

        # Convert to Netscape format
        netscape_cookies = convert_to_netscape_format(cookies)

        # Count YouTube-specific cookies
        yt_cookies = [c for c in cookies if 'youtube' in c.get('domain', '') or 'google' in c.get('domain', '')]
        print(f"Found {len(yt_cookies)} YouTube/Google cookies")

        # Check for essential cookies
        essential_cookies = ['SID', 'SSID', 'HSID', 'LOGIN_INFO']
        cookie_names = [c.get('name', '') for c in cookies]
        found_essential = [c for c in essential_cookies if c in cookie_names]

        if len(found_essential) < 2:
            print(f"Warning: Missing essential cookies. Found: {found_essential}")
        else:
            print(f"Essential cookies present: {found_essential}")

        # Save to file
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        output_file.write_text(netscape_cookies)

        # Set restrictive permissions
        os.chmod(output_path, 0o600)

        print(f"✓ Cookies saved to: {output_path}")
        print(f"  Timestamp: {datetime.now().isoformat()}")

        # Save browser state for future use
        state_path = output_path.replace('.txt', '_state.json')
        context.storage_state(path=state_path)
        os.chmod(state_path, 0o600)
        print(f"✓ Browser state saved to: {state_path}")

        return True

    except Exception as e:
        print(f"Error extracting cookies: {e}")
        return False


def refresh_cookies(
    email: str = None,
    password: str = None,
    output_path: str = None,
    interactive: bool = False,
    timeout: int = 300
) -> bool:
    """
    Main function to refresh YouTube cookies.

    Args:
        email: YouTube/Google email (or from YOUTUBE_EMAIL env)
        password: YouTube/Google password (or from YOUTUBE_PASSWORD env)
        output_path: Path to save cookies.txt (or from YTDLP_COOKIES_FILE env)
        interactive: Show browser window (for debugging/manual intervention)
        timeout: Max seconds to wait for login

    Returns:
        True if cookies were successfully exported
    """
    # Get credentials from env if not provided
    email = email or os.getenv('YOUTUBE_EMAIL')
    password = password or os.getenv('YOUTUBE_PASSWORD')
    output_path = output_path or os.getenv('YTDLP_COOKIES_FILE', './cookies.txt')

    if not email or not password:
        print("Error: YouTube credentials not provided.")
        print("Set YOUTUBE_EMAIL and YOUTUBE_PASSWORD environment variables,")
        print("or pass --email and --password arguments.")
        return False

    print("")
    print("=" * 60)
    print("YouTube Cookie Refresh")
    print("=" * 60)
    print(f"Email: {email}")
    print(f"Output: {output_path}")
    print(f"Mode: {'Interactive (browser visible)' if interactive else 'Headless'}")
    print(f"Login timeout: {timeout}s")
    print("=" * 60)
    print("")

    with sync_playwright() as p:
        # Launch browser
        browser = p.chromium.launch(
            headless=not interactive,
            args=[
                '--disable-blink-features=AutomationControlled',
                '--no-sandbox',
            ]
        )

        # Check for saved browser state
        state_path = output_path.replace('.txt', '_state.json')
        has_saved_state = os.path.exists(state_path)

        if has_saved_state:
            print(f"Found saved browser state: {state_path}")

        # Create context with realistic settings (and saved state if available)
        context = browser.new_context(
            viewport={'width': 1280, 'height': 720},
            user_agent='Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            locale='en-US',
            storage_state=state_path if has_saved_state else None,
        )

        page = context.new_page()

        try:
            # Step 1: Check if already logged in via saved state
            if has_saved_state:
                if check_already_logged_in(page):
                    # Already logged in! Just extract fresh cookies
                    if extract_and_save_cookies(context, page, output_path):
                        print("")
                        print("=" * 60)
                        print("SUCCESS: Cookies refreshed using saved state")
                        print("=" * 60)
                        browser.close()
                        return True

            # Step 2: Perform login
            if not perform_login(page, email, password):
                print("Failed to enter credentials")
                browser.close()
                return False

            # Step 3: Wait for login to complete (auto-detect, no manual Enter needed)
            success, reason = wait_for_login_success(page, timeout_seconds=timeout)

            if not success:
                print("")
                print("=" * 60)
                print("LOGIN FAILED")
                print("=" * 60)
                print(f"Reason: {reason}")
                print("")
                if 'timeout' in reason:
                    print("The login process timed out.")
                    print("Possible causes:")
                    print("  - 2FA challenge not completed in time")
                    print("  - Network issues")
                    print("  - Google security block")
                print("")
                print("Try running with --interactive flag to see the browser.")
                print("=" * 60)
                browser.close()
                return False

            # Step 4: Extract and save cookies
            if not extract_and_save_cookies(context, page, output_path):
                browser.close()
                return False

            print("")
            print("=" * 60)
            print("SUCCESS: YouTube cookies refreshed")
            print("=" * 60)
            browser.close()
            return True

        except Exception as e:
            print(f"Error during cookie refresh: {e}")
            browser.close()
            return False


def main():
    parser = argparse.ArgumentParser(
        description='Refresh YouTube cookies for yt-dlp',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Interactive mode (shows browser for 2FA)
    python refresh_youtube_cookies.py --interactive

    # Headless mode with env vars
    YOUTUBE_EMAIL=email@gmail.com YOUTUBE_PASSWORD=pass python refresh_youtube_cookies.py

    # Custom output
    python refresh_youtube_cookies.py --output ./cookies.txt --interactive

Environment Variables:
    YOUTUBE_EMAIL      - Google account email
    YOUTUBE_PASSWORD   - Google account password
    YTDLP_COOKIES_FILE - Default output path
        """
    )

    parser.add_argument(
        '--email', '-e',
        help='YouTube/Google email (or set YOUTUBE_EMAIL env var)'
    )
    parser.add_argument(
        '--password', '-p',
        help='YouTube/Google password (or set YOUTUBE_PASSWORD env var)'
    )
    parser.add_argument(
        '--output', '-o',
        default=os.getenv('YTDLP_COOKIES_FILE', './cookies.txt'),
        help='Output path for cookies.txt (default: ./cookies.txt)'
    )
    parser.add_argument(
        '--interactive', '-i',
        action='store_true',
        help='Show browser window (useful for 2FA or debugging)'
    )
    parser.add_argument(
        '--timeout', '-t',
        type=int,
        default=300,
        help='Timeout in seconds for login (default: 300)'
    )

    args = parser.parse_args()

    success = refresh_cookies(
        email=args.email,
        password=args.password,
        output_path=args.output,
        interactive=args.interactive,
        timeout=args.timeout
    )

    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
